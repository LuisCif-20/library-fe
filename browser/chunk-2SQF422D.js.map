{"version":3,"sources":["node_modules/@ngrx/operators/fesm2022/ngrx-operators.mjs","src/app/auth/interfaces/auth.store.interface.ts","src/app/auth/services/user.service.ts","src/app/auth/stores/auth.store.ts"],"sourcesContent":["import { of, EMPTY } from 'rxjs';\nimport { concatMap, withLatestFrom, map, catchError, tap, finalize } from 'rxjs/operators';\n\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nfunction concatLatestFrom(observablesFactory) {\n  return concatMap(value => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables) ? observables : [observables];\n    return of(value).pipe(withLatestFrom(...observablesAsArray));\n  });\n}\n\n/**\n * `mapResponse` is a map operator with included error handling.\n * It is similar to `tapResponse`, but allows to map the response as well.\n *\n * The main use case is for NgRx Effects which requires an action to be dispatched.\n *\n * @usageNotes\n * ```ts\n * export const loadAllUsers = createEffect((\n *   actions$ = inject(Actions),\n *   usersService = inject(UsersService)\n * ) => {\n *   return actions$.pipe(\n *     ofType(UsersPageActions.opened),\n *     exhaustMap(() => {\n *       return usersService.getAll().pipe(\n *         mapResponse({\n *           next: (users) => UsersApiActions.usersLoadedSuccess({ users }),\n *           error: (error) => UsersApiActions.usersLoadedFailure({ error }),\n *         })\n *       );\n *     })\n *   );\n * });\n * ```\n */\nfunction mapResponse(observer) {\n  return source$ => source$.pipe(map(value => observer.next(value)), catchError(error => of(observer.error(error))));\n}\n\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly dismissAlert = this.effect<Alert>((alert$) => {\n *   return alert$.pipe(\n *     concatMap(\n *       (alert) => this.alertsService.dismissAlert(alert).pipe(\n *         tapResponse(\n *           (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *           (error: { message: string }) => this.logError(error.message)\n *         )\n *       )\n *     )\n *   );\n * });\n *\n * readonly loadUsers = this.effect<void>((trigger$) => {\n *   return trigger$.pipe(\n *     tap(() => this.patchState({ loading: true })),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.patchState({ users }),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.patchState({ loading: false }),\n *         })\n *       )\n *     )\n *   );\n * });\n * ```\n */\nfunction tapResponse(observerOrNext, error, complete) {\n  const observer = typeof observerOrNext === 'function' ? {\n    next: observerOrNext,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: error,\n    complete\n  } : observerOrNext;\n  return source => source.pipe(tap({\n    next: observer.next,\n    complete: observer.complete\n  }), catchError(error => {\n    observer.error(error);\n    return EMPTY;\n  }), observer.finalize ? finalize(observer.finalize) : source$ => source$);\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { concatLatestFrom, mapResponse, tapResponse };\n","import { User } from \"./user.interface\";\n\nexport enum AuthStatus {\n  CHECKING,\n  AUTHENTICATED,\n  NOT_AUTHENTICATED\n}\n\nexport interface AuthState {\n  accessToken:  string | null;\n  authStatus:   AuthStatus;\n  user:         User | null;\n}\n","import { inject, Injectable } from '@angular/core';\nimport { environment } from '@envs/environment';\nimport { HttpClient } from '@angular/common/http';\n\nimport { Observable } from 'rxjs';\n\nimport { User } from '../interfaces/user.interface';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n\n  private readonly USER_URL = `${environment.API_URL}/users`;\n\n  private httpClient = inject(HttpClient);\n\n  constructor() { }\n\n  public getUserInfo(): Observable<User> {\n    const url = `${this.USER_URL}/me`;\n    return this.httpClient.get<User>(url);\n  }\n\n}\n","import { inject } from \"@angular/core\";\n\nimport { patchState, signalStore, withMethods, withProps, withState } from \"@ngrx/signals\";\nimport { mapResponse, tapResponse } from \"@ngrx/operators\";\n\nimport { AuthService } from \"../services/auth.service\";\nimport { AuthState, AuthStatus } from \"../interfaces/auth.store.interface\";\nimport { catchError, Observable, of, switchMap, throwError } from \"rxjs\";\nimport { AuthResponse, Login } from \"../interfaces/auth.interface\";\nimport { UserService } from \"../services/user.service\";\nimport { HttpErrorResponse } from \"@angular/common/http\";\n\nconst initialState: AuthState = {\n  user: null,\n  accessToken: null,\n  authStatus: AuthStatus.CHECKING\n}\n\nexport const AuthStore = signalStore(\n  {\n    providedIn: 'root'\n  },\n  withState<AuthState>(initialState),\n  withProps(() => ({\n    authService: inject(AuthService),\n    userService: inject(UserService)\n  })),\n  withMethods(({ authService, userService, ...store }) => ({\n    processAuthReq(req: Observable<AuthResponse>): Observable<boolean> {\n      return req.pipe(\n        switchMap(({ token }) => {\n          patchState(store, { accessToken: token });\n          return userService.getUserInfo().pipe(\n            mapResponse({\n              next: (user) => {\n                patchState(store, { user, authStatus: AuthStatus.AUTHENTICATED });\n                return true;\n              },\n              error: () => {\n                patchState(store, { accessToken: null });\n                return false;\n              }\n            })\n          )\n        }),\n        catchError(() => {\n          patchState(store, { authStatus: AuthStatus.NOT_AUTHENTICATED })\n          return of(false);\n        })\n      )\n    },\n    login(body: Login): Observable<boolean> {\n      return this.processAuthReq(authService.login(body));\n    },\n    logout(): Observable<void> {\n      return authService.logout().pipe(\n        tapResponse({\n          next: () => patchState(store, { user: null, accessToken: null, authStatus: AuthStatus.NOT_AUTHENTICATED }),\n          error: (error: HttpErrorResponse) => throwError(() => error)\n        })\n      );\n    },\n    checkAuth(): Observable<boolean> {\n      return this.processAuthReq(authService.refreshToken());\n    },\n    refreshToken(): Observable<AuthResponse> {\n      return authService.refreshToken().pipe(\n        tapResponse({\n          next: ({ token }) => patchState(store, { accessToken: token }),\n          error: () => patchState(store, { accessToken: null, user: null, authStatus: AuthStatus.NOT_AUTHENTICATED })\n        })\n      )\n    }\n  }))\n)\n"],"mappings":"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","names":["error","AuthStatus"],"x_google_ignoreList":[0]}